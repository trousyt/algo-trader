---
title: "Step 4: Order Management + Risk Management"
type: feat
date: 2026-02-15
parent: docs/plans/2026-02-13-feat-phase-1-trading-engine-plan.md
research: repo-research-analyst, learnings-researcher, spec-flow-analyzer
review: architecture-strategist, kieran-python-reviewer, code-simplicity-reviewer
specflow_gaps: 30 identified, all resolved
---

# Step 4: Order Management + Risk Management

## Overview

Build the order lifecycle management and risk enforcement components that sit between the Strategy Engine (Step 3) and the BrokerAdapter (Step 2). When a strategy generates a signal, the Risk Manager approves or rejects it, the Position Sizer calculates shares, and the Order Manager submits, tracks, and records orders through a state machine that guarantees data integrity even through crashes.

**Scope**: Order state machine, order lifecycle manager, position sizer, circuit breaker, risk manager facade. Does NOT include startup reconciliation (Step 5), backtesting (Step 6), or UI (Step 7).

## Problem Statement

Steps 1-3 built the data pipeline: broker streams 1-min bars -> CandleAggregator produces multi-minute candles -> IndicatorCalculator computes SMAs -> VelezStrategy detects entry/exit signals. But signals have nowhere to go. There is no:

- Order submission or lifecycle tracking
- Risk checks before order placement
- Position sizing calculation
- Daily loss limiting or circuit breaker
- Persistent record of orders, fills, and completed trades

Without these components, the system cannot trade -- even on paper.

## Proposed Solution

Five components with clean interfaces, testable in isolation:

1. **OrderStateMachine** -- Pure state transition logic with validation (no versioning, no force-set)
2. **OrderManager** -- Async lifecycle: submit, track fills, update stops, record trades
3. **PositionSizer** -- Decimal math: equity x risk% / stop distance = shares
4. **CircuitBreaker** -- Daily loss limit + consecutive loss pause
5. **RiskManager** -- Facade: combines sizer + breaker + account checks for pre-order approval

The OrderManager consumes `Signal` objects (new type) and produces structured logs via `structlog` for all lifecycle events.

---

## Technical Approach

### Architecture

```
Strategy Engine (Step 3)
    |
    | Signal(symbol, side, entry_price, stop_loss_price, ...)
    v
+----------------+         +----------------+
| RiskManager    |-------->| PositionSizer  |
|  (facade)      |         +----------------+
|                |-------->+----------------+
|                |         | CircuitBreaker |
+-------+--------+         +----------------+
        | RiskApproval(approved, qty, reason)
        v
+----------------+
| OrderManager   |---- structlog ----> (structured logging)
|                |
| +------------+ |         +----------------+
| |  State     | |-------->| BrokerAdapter  |
| |  Machine   | |         |  (Step 2)      |
| +------------+ |<--------|                |
|                | fills   +----------------+
| +------------+ |
| | SQLite     | |
| | (WAL)      | |
| +------------+ |
+----------------+
```

**Data flow**: Signal -> RiskManager.approve() -> OrderManager.submit_entry() -> BrokerAdapter -> fills stream back -> OrderManager state transitions -> Trade record persisted.

### New Domain Types

#### `app/orders/types.py`

```python
from datetime import datetime

class OrderState(str, Enum):
    """Local order lifecycle states."""
    PENDING_SUBMIT = "pending_submit"
    SUBMITTED = "submitted"
    ACCEPTED = "accepted"
    PARTIALLY_FILLED = "partially_filled"
    FILLED = "filled"
    CANCELED = "canceled"
    EXPIRED = "expired"
    REJECTED = "rejected"
    SUBMIT_FAILED = "submit_failed"

TERMINAL_STATES = frozenset({
    OrderState.FILLED,
    OrderState.CANCELED,
    OrderState.EXPIRED,
    OrderState.REJECTED,
    OrderState.SUBMIT_FAILED,
})

class OrderRole(str, Enum):
    """Purpose of an order within a trade lifecycle."""
    ENTRY = "entry"
    STOP_LOSS = "stop_loss"
    EXIT_MARKET = "exit_market"

@dataclass(frozen=True)
class Signal:
    """Strategy output -- request to open a position."""
    symbol: str
    side: Side
    entry_price: Decimal           # Buy-stop trigger price
    stop_loss_price: Decimal       # Initial stop-loss level
    order_type: OrderType          # STOP for buy-stop entry
    strategy_name: str
    timestamp: datetime            # When signal was generated

@dataclass(frozen=True)
class RiskApproval:
    """Risk Manager decision on a signal."""
    approved: bool
    qty: Decimal                   # 0 if rejected
    reason: str                    # "" if approved, rejection reason if not

@dataclass(frozen=True)
class SubmitResult:
    """Result of submitting an entry order."""
    local_id: str
    correlation_id: str            # Generated by OrderManager
    state: OrderState
    error: str                     # "" if no error
```

**Key changes from initial draft (post-review):**
- `REPLACED` state removed -- replace_order does in-place update on existing OrderStateModel
- `OrderActivity` queue removed -- replaced by `structlog` structured logging
- `correlation_id` removed from Signal -- generated by OrderManager
- `timestamp` added to Signal
- `SubmitResult` replaces bare `str` return from submit_entry()
- `OrderRole` enum added for order_role column

### Order State Machine

#### `app/orders/state_machine.py`

Pure synchronous logic -- no I/O, no database, no versioning. Validates state transitions and raises on invalid ones.

**State diagram:**

```
                    +--------------+
                    |PENDING_SUBMIT|
                    +------+-------+
                     +-----+-----+
                     v           v
              +-----------+  +------------+
              | SUBMITTED |  |SUBMIT_FAILED| (terminal)
              +-----+-----+  +------------+
            +---+---+---+--------+
            v   v   v   v        v
     +--------+ | +------+ +--------+
     |ACCEPTED| | |FILLED| |CANCELED|
     +---+----+ | +------+ +--------+
   +-----+-----+| (terminal) (terminal)
   v     v     vv
+------++------++--------++-------+
|PART. ||FILLED||CANCELED||EXPIRED|
|FILLED||      ||        ||       |
+--+---++------++--------++-------+
   |     (term.) (term.)   (term.)
   | loops back to self
   +---> PARTIALLY_FILLED
   +---> FILLED (terminal)
   +---> CANCELED (terminal)
```

**Transition table:**

| From | Valid To |
|------|----------|
| `PENDING_SUBMIT` | `SUBMITTED`, `SUBMIT_FAILED` |
| `SUBMITTED` | `ACCEPTED`, `REJECTED`, `FILLED`, `CANCELED`, `EXPIRED` |
| `ACCEPTED` | `PARTIALLY_FILLED`, `FILLED`, `CANCELED`, `EXPIRED` |
| `PARTIALLY_FILLED` | `PARTIALLY_FILLED`, `FILLED`, `CANCELED` |

**Key design decisions (post-review):**
- **No versioning** -- single asyncio process means no concurrent writers. The asyncio.Lock in RiskManager serializes signal processing. State machine validates from->to only.
- **No `force_state()`** -- reconciliation deferred to Step 5. When Step 5 needs it, it adds it.
- **No `REPLACED` state** -- `replace_order()` does an in-place update on the existing `OrderStateModel` (updating `broker_id` if Alpaca issues a new order ID). The replacement is logged in `order_event` for audit trail. This avoids creating spurious terminal states.
- `SUBMITTED -> EXPIRED` added (Alpaca can expire DAY orders that were submitted but never reached ACCEPTED -- rare but possible).
- All terminal states: `FILLED`, `CANCELED`, `EXPIRED`, `REJECTED`, `SUBMIT_FAILED` (5 total).

```python
class OrderStateMachine:
    TRANSITIONS: ClassVar[dict[OrderState, frozenset[OrderState]]] = { ... }

    def __init__(self, state: OrderState) -> None: ...

    def transition(self, to: OrderState) -> None:
        """Validate transition. Raises InvalidTransition on invalid from->to."""

    @property
    def is_terminal(self) -> bool: ...
```

### Order Manager

#### `app/orders/order_manager.py`

Async orchestrator for the full order lifecycle. Owns the database session for order operations.

**Responsibilities:**
1. Accept `Signal` + `RiskApproval` -> create entry order -> submit to broker
2. Process `TradeUpdate` events -> advance state machine -> persist
3. On entry fill -> submit stop-loss (via broker)
4. On stop update -> replace stop-loss order (in-place update)
5. On exit signal -> cancel stop, wait for event-based confirmation, sell at market
6. On fill (both sides) -> create `Trade` record
7. Track `candles_since_order` for pending entry expiry
8. Log all lifecycle events via `structlog`
9. Handle unknown `order_id` from broker (log warning, continue)

**Key interfaces:**

```python
class OrderManager:
    def __init__(
        self,
        broker: BrokerAdapter,
        session_factory: async_sessionmaker[AsyncSession],
    ) -> None:
        self._cancel_events: dict[str, asyncio.Event] = {}  # broker_id -> event
        ...

    async def submit_entry(
        self,
        signal: Signal,
        approval: RiskApproval,
    ) -> SubmitResult:
        """Submit entry order. Returns SubmitResult with local_id and correlation_id.

        Generates correlation_id internally (UUID).
        Creates OrderStateModel (PENDING_SUBMIT, role=ENTRY), submits via broker,
        transitions to SUBMITTED. On broker error -> SUBMIT_FAILED.
        """

    async def handle_trade_update(self, update: TradeUpdate) -> None:
        """Process a fill/cancel/reject event from broker.

        Matches update.order_id to local OrderStateModel.broker_id.
        If no match found: log warning and return (handle unknown order_id).
        Advances state machine, persists, handles side effects:
        - FILL on entry -> submit stop-loss
        - FILL on stop -> create Trade record, notify circuit breaker
        - PARTIAL_FILL -> update stop-loss qty via replace_order
        - CANCELED on partial entry -> close remaining at market
        """

    async def cancel_pending_entry(self, local_id: str) -> None:
        """Cancel an unfilled entry order (buy-stop expiry)."""

    async def request_exit(
        self,
        symbol: str,
        correlation_id: str,
    ) -> None:
        """Strategy exit signal. Cancel stop, wait for event confirmation, sell at market.

        1. Register asyncio.Event for the stop-loss broker_id
        2. Cancel active stop-loss for this correlation_id
        3. Wait for event confirmation (handle_trade_update sets the event)
        4. Check if position still exists (stop may have filled during cancel)
        5. If still holding -> submit market sell
        6. If flat -> done (stop already filled)
        """

    async def update_stop_loss(
        self,
        correlation_id: str,
        new_stop_price: Decimal,
    ) -> None:
        """Update active stop-loss price via replace_order.

        In-place update: updates broker_id on existing OrderStateModel
        if Alpaca issues new order ID. Logs replacement in order_event.
        """

    async def on_candle(self, symbol: str) -> None:
        """Called each candle. Increments candles_since_order for pending entries."""

    async def cancel_all_pending(self) -> None:
        """Cancel all pending unfilled entry orders. Called on startup."""
```

**Database write pattern:**

Every state transition performs these two writes in a **single database transaction**:
1. UPDATE `order_state` SET `state`, `updated_at`, (+ fill fields if applicable)
2. INSERT into `order_event` (append-only audit log)

Transaction ensures atomicity -- a crash between the two writes cannot leave inconsistent state.

```python
async with self._session_factory() as session:
    async with session.begin():
        # 1. Read current order
        result = await session.execute(
            select(OrderStateModel).where(
                OrderStateModel.local_id == local_id
            )
        )
        order = result.scalar_one()

        # 2. Transition state machine (validates from->to)
        machine = OrderStateMachine(OrderState(order.state))
        machine.transition(new_state)

        # 3. Update order_state
        order.state = new_state.value
        order.updated_at = format_timestamp(utc_now())

        # 4. Append order_event
        session.add(OrderEventModel(
            order_local_id=order.local_id,
            event_type=event_type,
            old_state=old_state.value,
            new_state=new_state.value,
            recorded_at=format_timestamp(utc_now()),
            ...
        ))
        # Transaction commits here
```

**Exit signal with event-based cancellation:**

```python
async def request_exit(self, symbol: str, correlation_id: str) -> None:
    stop_order = await self._find_active_stop(correlation_id)
    if stop_order is None:
        return  # No active stop to cancel

    # Register event for this broker order
    cancel_event = asyncio.Event()
    self._cancel_events[stop_order.broker_id] = cancel_event

    # Request cancellation
    await self._broker.cancel_order(stop_order.broker_id)
    log.info("stop_cancel_requested", broker_id=stop_order.broker_id)

    # Wait for broker confirmation (handle_trade_update sets event)
    try:
        await asyncio.wait_for(cancel_event.wait(), timeout=5.0)
    except asyncio.TimeoutError:
        log.warning("stop_cancel_timeout", broker_id=stop_order.broker_id)
    finally:
        self._cancel_events.pop(stop_order.broker_id, None)

    # Check if we still hold the position
    position = await self._broker.get_position(symbol)
    if position is not None and position.qty > Decimal("0"):
        await self._submit_market_exit(symbol, correlation_id, position.qty)
```

In `handle_trade_update()`, after processing a CANCELED event:
```python
# Signal any waiting cancel_event
event = self._cancel_events.get(update.order_id)
if event is not None:
    event.set()
```

**Trade record creation:**

```python
def _trade_side_from_entry(entry_side: Side) -> str:
    """Map entry order side to trade position side."""
    return {Side.BUY: "long", Side.SELL: "short"}[entry_side]

trade = TradeModel(
    trade_id=str(uuid4()),
    correlation_id=correlation_id,
    symbol=symbol,
    side=_trade_side_from_entry(entry_order.side),
    qty=str(entry_filled_qty),
    entry_price=str(entry_avg_fill_price),
    exit_price=str(exit_avg_fill_price),
    entry_at=entry_fill_timestamp,
    exit_at=exit_fill_timestamp,
    pnl=str(pnl),                          # (exit - entry) * qty
    pnl_pct=str(pnl_pct),                  # pnl / (entry * qty) as fraction
    strategy=strategy_name,
    duration_seconds=duration,
    commission="0",                         # Alpaca: $0; future brokers populate
)
```

Note: `pnl_pct` stored as a fraction (e.g., `0.0084` not `0.84`). Display layer converts to percentage.

**Candle tracking for pending order expiry:**

The OrderManager maintains an in-memory dict `{local_id: candles_elapsed}`. Each call to `on_candle(symbol)` increments the counter for any pending (ACCEPTED, not yet filled) entry orders for that symbol. The TradingEngine (Step 5) calls `on_candle()` after each aggregated candle, and the strategy's `should_cancel_pending(bar, candles_since_order)` determines whether to cancel.

On restart, `cancel_all_pending()` cancels all non-terminal entry orders rather than trying to reconstruct candle counts.

**Entry fill -> stop-loss placement:**

When an entry fill arrives, the OrderManager:
1. Records the fill in the state machine + DB
2. Calls `broker.submit_order(OrderRequest(side=SELL, order_type=STOP, stop_price=stop_loss_price, qty=filled_qty))`
3. Tracks the stop-loss as a separate `OrderStateModel` with `role=STOP_LOSS`, linked by `correlation_id` and `parent_id`
4. If stop submission fails: retry 3x with 1s backoff, then market sell fallback (log CRITICAL)

**Multiple partial fills -> stop-loss quantity management:**

On each partial fill:
1. If no stop-loss exists yet -> submit new stop-loss for `filled_qty`
2. If stop-loss already exists -> `replace_order(stop_broker_id, qty=new_total_filled_qty)`
3. A single stop-loss order is maintained, with qty updated on each partial fill

**Partial fill + cancel -> auto-close:**

If entry is CANCELED with any `filled_qty > 0`:
1. Cancel the stop-loss for the partial
2. Submit market sell for `filled_qty` shares
3. Create Trade record with the partial position

No magic number threshold -- any partial fill that gets canceled triggers a close.

**Replace order handling (in-place update):**

When `replace_order()` succeeds and Alpaca issues a new broker order ID:
1. Update `OrderStateModel.broker_id` to the new broker ID
2. Append `OrderEventModel` with `event_type="replaced"` recording old and new broker IDs
3. State remains unchanged (e.g., ACCEPTED stays ACCEPTED)

**Unknown order_id handling:**

When `handle_trade_update()` receives an `order_id` that doesn't match any `OrderStateModel.broker_id`:
1. Log warning with full update details via structlog
2. Return without processing
3. This handles orders from previous sessions, manual trades, etc.

**Structured logging (replaces OrderActivity queue):**

All lifecycle events logged via `structlog` with consistent fields:

| Event Name | When | Key Fields |
|---|---|---|
| `signal_detected` | Strategy signal received | symbol, side, entry_price, stop_price |
| `risk_rejected` | RiskManager rejects | symbol, reason |
| `order_submitted` | Entry/stop sent to broker | symbol, local_id, role, qty, price |
| `order_filled` | Entry or exit fills | symbol, local_id, qty, fill_price |
| `order_canceled` | Order canceled | symbol, local_id, reason |
| `order_rejected` | Broker rejects | symbol, local_id, reason |
| `stop_moved` | Trailing stop updated | symbol, old_price, new_price |
| `circuit_breaker_tripped` | CB trips | reason, daily_pnl, consecutive_losses |
| `circuit_breaker_reset` | Daily reset | start_of_day_equity |
| `trade_closed` | Trade record created | symbol, pnl, pnl_pct, duration |
| `stop_fallback_market_sell` | Stop submit failed, market sell | symbol, qty |
| `unknown_order_update` | Unrecognized order_id | broker_order_id, event_type |

### Position Sizer

#### `app/risk/position_sizer.py`

Pure function -- no I/O, no state. All math in `Decimal`.

**Formula:**

```
risk_amount = min(equity * max_risk_per_trade_pct, max_risk_per_trade_abs)
stop_distance = abs(entry_price - stop_loss_price)
raw_shares = risk_amount / stop_distance
qty = Decimal(int(raw_shares))              # Truncate to whole shares (conservative)

# Clamp to max position size
max_position_value = equity * max_position_pct
max_qty_by_value = Decimal(int(max_position_value / entry_price))
qty = min(qty, max_qty_by_value)

# Clamp to buying power
max_qty_by_power = Decimal(int(buying_power / entry_price))
qty = min(qty, max_qty_by_power)
```

Note: `qty` is `Decimal` (not `int`) to support brokers/markets with fractional shares. Truncation to whole shares is explicit via `Decimal(int(...))` -- change the truncation logic if fractional share support is needed later.

**Interface:**

```python
@dataclass(frozen=True)
class SizingResult:
    qty: Decimal                   # Decimal for fractional share compatibility
    risk_amount: Decimal           # Dollar risk for this position
    stop_distance: Decimal
    position_value: Decimal        # qty * entry_price
    reason: str                    # "" if valid, rejection reason if qty=0

class PositionSizer:
    def __init__(self, risk_config: RiskConfig) -> None: ...

    def calculate(
        self,
        equity: Decimal,
        buying_power: Decimal,
        entry_price: Decimal,
        stop_loss_price: Decimal,
    ) -> SizingResult:
        """Calculate position size. Returns qty=0 with reason if cannot size."""
```

**Edge cases:**
- `stop_distance == 0` -> reject ("Stop distance is zero")
- `raw_shares < 1` -> reject ("Risk budget too small for stop distance")
- `entry_price <= 0` -> reject ("Invalid entry price")
- `buying_power < entry_price` -> reject ("Insufficient buying power for even 1 share")

**Equity source:** Uses current `AccountInfo.equity` (includes unrealized P&L). This is the most conservative choice -- equity shrinks after losses, naturally reducing position sizes.

### Circuit Breaker

#### `app/risk/circuit_breaker.py`

Tracks daily realized P&L and consecutive losses. Pauses new entries when limits are hit. Existing positions with stop-losses remain active.

**State:**

```python
class CircuitBreaker:
    def __init__(
        self,
        max_daily_loss_pct: Decimal,
        consecutive_loss_pause: int,
    ) -> None:
        self._start_of_day_equity: Decimal = Decimal("0")
        self._daily_realized_pnl: Decimal = Decimal("0")
        self._consecutive_losses: int = 0
        self._paused: bool = False
        self._pause_reason: str = ""

    def reset_daily(self, start_of_day_equity: Decimal) -> None:
        """Called at market open. Resets all daily counters."""

    def record_trade(self, pnl: Decimal) -> None:
        """Called when a Trade record is created.

        - Adds pnl to daily_realized_pnl
        - If pnl <= 0: increments consecutive_losses
        - If pnl > 0: resets consecutive_losses to 0
        - Checks both limits, sets paused if either exceeded
        """

    def can_trade(self) -> tuple[bool, str]:
        """Returns (True, "") or (False, "reason")."""

    def reconstruct_from_trades(
        self,
        today_trades: list[TradeModel],
        start_of_day_equity: Decimal,
    ) -> None:
        """Reconstruct state from trade table after restart.

        Replays all today's trades in chronological order.
        """
```

**Design decisions:**
- **Daily P&L = realized only** -- unrealized P&L is too volatile and would cause the breaker to flicker on/off. Realized means "closed trades today."
- **Consecutive losses = global** (across all symbols) -- more conservative, simpler. Three losses on three different symbols still triggers the pause.
- **Break-even = loss** -- `pnl <= 0` counts as a loss for consecutive tracking. A $0.00 trade doesn't reset the streak.
- **Reset timing = market open** -- `reset_daily()` called when first candle of new trading day arrives. Uses exchange-calendars to determine trading days.
- **State reconstruction** -- on restart, queries `Trade` table for today's trades (by `exit_at` date), replays `record_trade()` for each in order. Deterministic.

### Risk Manager Facade

#### `app/risk/risk_manager.py`

Orchestrates all pre-order checks. Serializes access with `asyncio.Lock` to prevent concurrent signals from bypassing limits. No caching -- calls `broker.get_account()` every time (signals are infrequent, ~5 per 2-minute candle at most).

```python
class RiskManager:
    def __init__(
        self,
        risk_config: RiskConfig,
        broker: BrokerAdapter,
        circuit_breaker: CircuitBreaker,
        position_sizer: PositionSizer,
        session_factory: async_sessionmaker[AsyncSession],
    ) -> None:
        self._lock = asyncio.Lock()

    async def approve(
        self,
        signal: Signal,
    ) -> RiskApproval:
        """Pre-order approval. Serialized via asyncio.Lock.

        Checks in order (fail-fast):
        1. Circuit breaker: can_trade()?
        2. Open positions: count < max_open_positions? (computed internally)
        3. Account data: fetch from broker (no cache)
        4. Position sizer: calculate qty
        5. Return RiskApproval(approved=True, qty=qty)
        """

    async def _count_open_positions(self) -> int:
        """Query order_state for non-terminal entry orders. Internal."""
```

**Key changes from initial draft (post-review):**
- `open_position_count` parameter removed -- RiskManager queries the DB itself
- Account cache removed -- `broker.get_account()` called directly (signals are infrequent)
- `session_factory` added to constructor for position count queries

### Alpaca Adapter: No Changes Needed

The OrderManager always submits entry and stop-loss as separate operations. No bracket-split logic in the adapter. The existing `submit_order()`, `cancel_order()`, and `replace_order()` methods on `AlpacaBrokerAdapter` are sufficient.

The `BracketOrderRequest` type and `submit_bracket_order()` remain available for future market/limit entry strategies (Phase 2) but are not used by the Velez strategy path.

### Database Migration

#### `backend/alembic/versions/002_step4_order_schema_updates.py`

Two changes in one migration:

1. **Fix `order_state.side` CHECK constraint**: Change from `IN ('long', 'short')` to `IN ('buy', 'sell')` -- orders have a direction (buy/sell), trades have a position side (long/short)
2. **Add `order_role` column**: `String, nullable=False, server_default='entry'` with CHECK `IN ('entry', 'stop_loss', 'exit_market')`
3. **Add `strategy` column**: `String, nullable=True` -- which strategy placed this order
4. **Add index on `parent_id`**: `ix_order_state_parent_id`

Since SQLite doesn't support `ALTER TABLE ... ALTER CONSTRAINT`, this requires `render_as_batch=True` (already configured in alembic/env.py) to recreate the table.

---

## Implementation Phases

### Phase A: Domain Types + State Machine (pure logic, no I/O)

**Files:**
- `backend/app/orders/__init__.py`
- `backend/app/orders/types.py` -- `OrderState`, `OrderRole`, `Signal`, `RiskApproval`, `SubmitResult`, `TERMINAL_STATES`
- `backend/app/orders/state_machine.py` -- `OrderStateMachine`, `InvalidTransition`

**Tests:**
- `backend/tests/unit/test_order_state_machine.py`
  - All valid transitions (parametrized)
  - All invalid transitions raise `InvalidTransition`
  - Terminal state detection
  - Self-transition: PARTIALLY_FILLED -> PARTIALLY_FILLED
  - Property-based tests via Hypothesis: random event sequences never produce invalid state

**Acceptance:**
- [x] All 9 states defined with correct terminal set (5 terminal)
- [x] All valid transitions from the table work
- [x] Invalid transitions raise `InvalidTransitionError` with descriptive message (includes from/to states)
- [x] Hypothesis finds no invalid state sequences (300+ examples)
- [x] mypy clean, ruff clean

### Phase B: Risk Management (pure logic, no I/O except account fetch)

**Files:**
- `backend/app/risk/__init__.py`
- `backend/app/risk/position_sizer.py` -- `PositionSizer`, `SizingResult`
- `backend/app/risk/circuit_breaker.py` -- `CircuitBreaker`
- `backend/app/risk/risk_manager.py` -- `RiskManager`

**Tests:**
- `backend/tests/unit/test_position_sizer.py`
  - 1% risk, $0.50 stop, $25K equity = 500 shares
  - Max position % clamp
  - Buying power clamp
  - Zero stop distance -> rejection
  - Qty rounds to 0 -> rejection
  - All calculations use exact Decimal (not `pytest.approx`)
- `backend/tests/unit/test_circuit_breaker.py`
  - 3 consecutive losses -> paused
  - Win resets consecutive count
  - Daily loss limit trips when realized P&L exceeds threshold
  - Break-even (pnl=0) counts as loss
  - `reset_daily()` clears all state
  - `reconstruct_from_trades()` replays correctly
- `backend/tests/unit/test_risk_manager.py`
  - Approved signal with valid sizing
  - Rejected: circuit breaker tripped
  - Rejected: max open positions reached (mock DB query)
  - Rejected: position size rounds to 0
  - Rejected: insufficient buying power
  - No account cache -- each call hits mock broker

**Test factories to add to `backend/tests/factories.py`:**
- `make_signal(symbol="AAPL", entry_price=Decimal("155.20"), timestamp=utc_now(), ...)`
- `make_account_info(equity=Decimal("25000"), ...)`

**Acceptance:**
- [x] Position sizing: 1% risk, $0.50 stop, $25K equity = 500 shares
- [x] Risk manager rejects when daily loss limit exceeded
- [x] Circuit breaker trips after `consecutive_loss_pause` consecutive losses
- [x] Circuit breaker resets on daily reset
- [x] RiskManager serializes concurrent approve() calls
- [x] RiskManager computes open position count internally (no param)
- [x] All Decimal -- no float in money paths
- [x] mypy clean, ruff clean

### Phase C: Order Manager (async I/O, depends on Phase A + B)

**Files:**
- `backend/app/orders/order_manager.py` -- `OrderManager`

**Tests:**
- `backend/tests/unit/test_order_manager.py`
  - Submit entry -> SubmitResult with local_id and correlation_id
  - Handle fill -> state transition + stop-loss submitted with role=STOP_LOSS
  - Handle partial fill -> stop-loss with correct qty
  - Handle cancel on partial -> market sell (no minimum threshold)
  - Handle rejected -> terminal state
  - Replace order -> in-place update (broker_id updated, event logged)
  - Exit signal -> cancel stop via asyncio.Event, verify, sell
  - Candle counter increments correctly
  - Trade record created with correct P&L math and trade_side_from_entry()
  - Write-ahead: state + event persisted in single transaction
  - Unknown order_id -> log warning, no crash
  - cancel_all_pending() cancels all non-terminal entries
  - Uses mock BrokerAdapter + in-memory SQLite
  - Structured log assertions via structlog testing utilities

**Test helpers:**
- `FakeBrokerAdapter` (already exists in `tests/unit/test_fake_adapters.py` -- extend with order tracking)
- In-memory async SQLite session for database tests

**Acceptance:**
- [x] submit_entry() returns SubmitResult with generated correlation_id
- [x] Every state transition persisted to `order_state` + appended to `order_event` before next action
- [x] Fill creates Trade record with correct pnl = `(exit_price - entry_price) * qty`
- [x] Partial fill + cancel -> auto-close at market (any qty, no magic number)
- [x] Stop-loss updated via replace_order on each partial fill (in-place update)
- [x] Exit signal: cancel stop -> asyncio.Event confirmation -> sell if holding
- [x] Unknown order_id from broker -> log warning, continue
- [x] cancel_all_pending() works for startup
- [x] Lifecycle events logged via structlog
- [x] mypy clean, ruff clean

### Phase D: Database Migration + Integration Wiring

**Files:**
- `backend/alembic/versions/002_step4_order_schema_updates.py`
- `backend/app/orders/__init__.py` -- re-exports
- `backend/app/risk/__init__.py` -- re-exports

**Tasks:**
- [x] Alembic migration: fix `order_state.side` CHECK from `'long'/'short'` to `'buy'/'sell'`
- [x] Alembic migration: add `order_role` column with CHECK constraint
- [x] Alembic migration: add `strategy` column
- [x] Alembic migration: add index on `parent_id`
- [x] Package re-exports for clean imports
- [x] Integration test: full signal -> approve -> submit -> fill -> trade cycle with in-memory DB

**Tests:**
- `backend/tests/integration/test_order_lifecycle.py`
  - Full happy path: signal -> risk approval -> submit entry -> fill -> stop-loss placed -> stop fills -> trade recorded
  - Rejection path: circuit breaker blocks signal
  - Partial fill path: partial -> stop placed -> remaining canceled -> stop qty updated -> auto-close

**Acceptance:**
- [x] Migration runs cleanly against existing database
- [x] Integration test covers full signal-to-trade lifecycle
- [x] All 327+ existing tests still pass (no regressions) -- 453 passing
- [x] mypy clean, ruff clean across entire codebase

---

## Alternative Approaches Considered

### 1. Bracket Order Abstraction in Adapter (Rejected)

Initially considered hiding the buy-stop bracket split entirely inside `AlpacaBrokerAdapter.submit_bracket_order()`. Rejected because:
- The OrderManager needs to track entry and stop-loss as separate database records anyway
- The retry + market-sell fallback for failed stop-loss is order management logic, not broker logic
- Simpler to have the OrderManager explicitly manage both orders
- Works identically across any broker -- no broker-specific bracket-split code

### 2. Event Sourcing for Order State (Considered, Deferred)

Full event sourcing (derive state from replaying events) would give perfect audit trails and crash recovery. Deferred because:
- Current approach (mutable state + append-only events) gives the same audit trail
- Event sourcing adds complexity (projection, snapshotting) for marginal benefit
- Can migrate to event sourcing later if needed (the `order_event` table already captures all events)

### 3. Per-Symbol Circuit Breaker (Rejected)

Tracking consecutive losses per-symbol would allow continuing to trade other symbols after losses on one. Rejected because:
- Three losses across different symbols still indicates something is wrong (market-wide)
- Global is simpler and more conservative
- Phase 1 priority is safety, not trade frequency

### 4. Unrealized P&L in Circuit Breaker (Rejected)

Including unrealized P&L in the daily loss check would trigger earlier. Rejected because:
- Unrealized P&L fluctuates constantly -- breaker would flicker on/off
- A large unrealized loss might recover
- Realized-only is the industry standard for daily loss limits

### 5. Optimistic Concurrency Versioning (Rejected -- YAGNI)

Initially planned a `version` column with check-and-set on every write. Rejected because:
- Single asyncio process = single writer = no concurrent updates possible
- asyncio.Lock in RiskManager already serializes signal processing
- Adds complexity (retry loops, ConcurrencyError handling) for zero benefit
- If we later move to multi-process, add versioning then

### 6. REPLACED as Terminal State (Rejected -- Simpler In-Place)

Initially planned `REPLACED` as a terminal state where replacing an order creates a new OrderStateModel row. Rejected because:
- Creates unnecessary database rows for what's logically the same order
- Complicates queries (need to follow parent chains)
- In-place update of `broker_id` + audit event achieves the same traceability with less complexity

### 7. OrderActivity Queue for Dashboard (Rejected -- YAGNI)

Initially planned an `asyncio.Queue[OrderActivity]` for dashboard consumption. Rejected because:
- Dashboard doesn't exist yet (Step 7)
- structlog provides the same information with less code
- When Step 7 needs real-time events, it can subscribe to structlog or add a queue then
- Premature abstraction adds an untested consumer interface

---

## Acceptance Criteria

### Functional (from Phase 1 plan + SpecFlow gaps + review)

- [x] Order state machine: all 9 states, all valid transitions work, invalid transitions raise error
- [x] Replace order does in-place update (no REPLACED terminal state)
- [x] Every state transition persisted to `order_state` + appended to `order_event` BEFORE next action
- [x] Risk manager rejects order when daily loss limit exceeded (existing positions untouched)
- [x] Circuit breaker trips after N consecutive losses, resets next trading day
- [x] Position sizing: 1% risk with $0.50 stop distance on $25K equity = 500 shares
- [x] Position sizing rounds DOWN (conservative) -- uses `Decimal(int(...))`
- [x] Buying power check prevents over-sized orders
- [x] Max open positions enforced even with concurrent signals (asyncio.Lock)
- [x] RiskManager computes open position count internally
- [x] Entry fill -> stop-loss submitted immediately (with role=STOP_LOSS)
- [x] Partial fills -> stop-loss qty updated via replace_order (in-place)
- [x] Partial fill + cancel -> auto-close at market (any qty, no magic threshold)
- [x] Exit signal: cancel stop -> asyncio.Event confirmation -> sell if holding
- [x] Trade record created with correct P&L, duration, and trade_side_from_entry()
- [x] Circuit breaker reconstructs from trade table on restart
- [x] cancel_all_pending() cancels unfilled entries on restart
- [x] Unknown broker order_id handled gracefully (log warning, continue)
- [x] All lifecycle events logged via structlog with consistent fields

### Non-Functional

- [x] All monetary calculations use Decimal (no float for prices, P&L, equity, sizing)
- [x] Database writes use transactions (order_state + order_event atomic)
- [x] mypy strict passes with zero errors
- [x] ruff format + ruff check clean

### Quality Gates

- [x] All new unit tests pass
- [x] All 327+ existing tests pass (no regressions)
- [x] Property-based tests pass (Hypothesis: 200+ examples)
- [x] Integration test: full signal-to-trade lifecycle
- [x] Test coverage: every state transition, every rejection path, every edge case

---

## Dependencies & Prerequisites

### Required (already exist)

| Dependency | Location | Status |
|---|---|---|
| `BrokerAdapter` protocol | `app/broker/broker_adapter.py` | Done (Step 2) |
| `OrderRequest`, `TradeUpdate`, etc. | `app/broker/types.py` | Done (Step 2) |
| `Strategy` base class | `app/strategy/base.py` | Done (Step 3) |
| `RiskConfig` | `app/config.py` | Done (Step 1) |
| `OrderStateModel`, `OrderEventModel`, `TradeModel` | `app/models/order.py` | Done (Step 1) |
| `DecimalText` type | `app/models/base.py` | Done (Step 1) |
| SQLite + Alembic | `alembic/` | Done (Step 1) |
| `AlpacaBrokerAdapter` | `app/broker/alpaca/broker.py` | Done (Step 2) |

### Deferred to Later Steps

| Item | Deferred To | Reason |
|---|---|---|
| Startup reconciliation + force_state() | Step 5 | Separate concern: comparing broker state vs DB |
| `TradingEngine` orchestrator | Step 5/7 | Ties all components together |
| Indicator extensibility | Step 5 | Affects TradingEngine, not order/risk |
| WebSocket dashboard events | Step 7 | structlog now, real-time events when dashboard exists |
| Backtest fill simulation | Step 6 | Uses same OrderStateMachine but mock broker |
| Property-based edge case testing | Follow-up | Hypothesis tests for state machine + position sizer |

---

## Risk Analysis & Mitigation

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Race condition: two signals bypass max_open_positions | Medium | High | `asyncio.Lock` on `RiskManager.approve()` |
| Stop-loss submission fails after entry fill | Low | Critical | Retry 3x with 1s backoff, market sell fallback. Log CRITICAL. |
| Exit signal + stop fill race -> double sell | Low | Critical | Cancel stop -> asyncio.Event confirmation -> check position -> sell if holding |
| SQLite write contention (state + event in transaction) | Low | Low | WAL mode + busy_timeout + single writer (asyncio) |
| Partial fill edge cases (qty mismatch) | Medium | Medium | replace_order for qty updates; any partial cancel -> close at market |
| Circuit breaker state lost on restart | Medium | High | Reconstruct from trade table (deterministic) |
| Unknown order_id from broker | Medium | Low | Log warning, continue processing (handled from day one) |

---

## File Summary

### New Files

| File | Purpose | Lines (est.) |
|---|---|---|
| `backend/app/orders/__init__.py` | Package re-exports | ~15 |
| `backend/app/orders/types.py` | OrderState, OrderRole, Signal, RiskApproval, SubmitResult | ~60 |
| `backend/app/orders/state_machine.py` | OrderStateMachine, InvalidTransition | ~70 |
| `backend/app/orders/order_manager.py` | OrderManager (async lifecycle) | ~300 |
| `backend/app/risk/__init__.py` | Package re-exports | ~10 |
| `backend/app/risk/position_sizer.py` | PositionSizer, SizingResult | ~80 |
| `backend/app/risk/circuit_breaker.py` | CircuitBreaker | ~100 |
| `backend/app/risk/risk_manager.py` | RiskManager facade | ~80 |
| `backend/alembic/versions/002_step4_order_schema_updates.py` | Migration: fix side CHECK, add columns/index | ~50 |
| `backend/tests/unit/test_order_state_machine.py` | State machine unit tests + Hypothesis | ~200 |
| `backend/tests/unit/test_position_sizer.py` | Position sizer unit tests | ~150 |
| `backend/tests/unit/test_circuit_breaker.py` | Circuit breaker unit tests | ~150 |
| `backend/tests/unit/test_risk_manager.py` | Risk manager unit tests | ~150 |
| `backend/tests/unit/test_order_manager.py` | Order manager unit tests | ~300 |
| `backend/tests/integration/test_order_lifecycle.py` | Full lifecycle integration | ~200 |

### Modified Files

| File | Change |
|---|---|
| `backend/tests/factories.py` | Add `make_signal()`, `make_account_info()`, `make_trade_model()` |
| `backend/app/models/order.py` | Add `order_role`, `strategy` columns; add `parent_id` index |

**Estimated total**: ~1,700 lines of new code + tests (reduced from ~2,200 after review simplifications)

---

## References

### Internal

- Phase 1 plan: `docs/plans/2026-02-13-feat-phase-1-trading-engine-plan.md` (lines 783-833: state machine, lines 488-633: DB schemas, lines 651-657: risk config, lines 806-827: partial fills + reconciliation)
- Broker types: `backend/app/broker/types.py`
- Strategy base: `backend/app/strategy/base.py`
- Config: `backend/app/config.py` (lines 34-58: RiskConfig)
- DB models: `backend/app/models/order.py`
- Alpaca adapter: `backend/app/broker/alpaca/broker.py`
- Decimal boundary: `docs/solutions/architecture-decisions/decimal-for-money-float-for-math.md`
- Alpaca threading: `docs/solutions/integration-issues/alpaca-py-async-threading-bridge.md`
- API error mocking: `docs/solutions/integration-issues/alpaca-py-api-error-mocking.md`
- Replace order qty: `docs/solutions/test-failures/alpaca-py-replace-order-qty-type.md`

### Review Findings Incorporated

| # | Finding | Resolution |
|---|---|---|
| P1-1 | request_exit() uses timeout, not event | Rewritten with asyncio.Event per order |
| P1-2 | Optimistic concurrency versioning is YAGNI | Removed -- single asyncio process, no concurrent writers |
| P1-3 | force_state() not needed until Step 5 | Removed entirely -- add when reconciliation is built |
| P1-4 | REPLACED state adds complexity | Removed -- replace_order does in-place update + audit event |
| P1-5 | OrderActivity queue is premature | Removed -- replaced by structlog structured logging |
| P1-6 | Unknown order_id unhandled | Log warning and continue from day one |
| P1-7 | session.get() is wrong API | Use select().where().scalar_one() |
| P2-8 | candles_since_order lost on restart | cancel_all_pending() on startup instead |
| P2-9 | Order role unclear from schema | Added order_role column (ENTRY, STOP_LOSS, EXIT_MARKET) |
| P2-10 | open_position_count passed as param | RiskManager computes internally via DB query |
| P2-11 | SizingResult.qty should be int | REJECTED -- kept as Decimal for fractional share support |
| P2-13 | Signal missing timestamp | Added timestamp: datetime to Signal |
| P2-14 | Test factory for Signal | Added make_signal() to factories.py |
| P2-15 | submit_entry() returns bare str | Returns SubmitResult(local_id, correlation_id, state, error) |
| P2-16 | No index on parent_id | Added to migration |
| P2-17 | No strategy on order_state | Added strategy column |
| P2-18 | Account cache adds complexity | Removed -- call broker.get_account() directly |
| P2-19 | `< 5 shares` is magic number | Removed -- any partial fill + cancel triggers close |
| P2-20 | Hardcoded side="long" | Added trade_side_from_entry() mapping |
| P3 | shutdown(), get_active_orders(), get_open_position_correlation() | Removed (YAGNI) |
| P3 | pnl_pct stored ambiguously | Documented as fraction (0.0084 not 0.84%) |
| P3 | Timestamp formatting inconsistent | Use format_timestamp(utc_now()) everywhere |
| P3 | correlation_id from caller | Generated by OrderManager internally |

### SpecFlow Gap Resolutions

| # | Gap | Resolution |
|---|---|---|
| 1 | Side enum mismatch (order_state) | Migration: change CHECK to `'buy'/'sell'` |
| 2 | SUBMITTED -> EXPIRED missing | Added to transition table |
| 3 | REPLACED not in state machine | Removed -- in-place update instead |
| 4 | Version column unused | Removed -- single writer, no need |
| 5 | Reconciliation force-set scope | Deferred to Step 5 entirely |
| 6 | Bracket with buy-stop | OrderManager submits entry + stop separately (all brokers) |
| 7 | Signal interface undefined | `Signal` frozen dataclass with timestamp |
| 8 | Trailing stop: replace vs cancel+resubmit | Use `replace_order()` (in-place update) |
| 9 | Multiple partials: stop qty | Single stop, qty updated via `replace_order` on each partial |
| 10 | Stop-loss rejected | Retry 3x, market sell fallback |
| 11 | candles_since_order tracking | In-memory dict + cancel_all_pending() on restart |
| 12 | Exit + stop race | Cancel stop -> asyncio.Event -> check position -> sell if holding |
| 13 | Event emission interface | structlog structured logging (not queue) |
| 14 | Equity figure for sizing | Current `AccountInfo.equity` |
| 15 | Buying power check | Separate clamp step in PositionSizer |
| 16 | Entry price in sizer | Buy-stop price as estimate |
| 17 | Rounding mode | `Decimal(int())` truncation (conservative) |
| 18 | Daily P&L basis | Realized-only |
| 19 | Circuit breaker reset timing | Market open (exchange-calendars) |
| 20 | Break-even = loss? | Yes, `pnl <= 0` counts as loss |
| 21 | CB state persistence | Reconstruct from trade table on startup |
| 22 | Global vs per-symbol losses | Global |
| 23 | Fail-fast vs exhaustive checks | Fail-fast (first rejection) |
| 24 | Concurrent signal serialization | `asyncio.Lock` on `approve()` |
| 25 | RiskApproval return type | Frozen dataclass: `approved`, `qty`, `reason` |
| 26 | Transaction boundaries | Single transaction for order_state + order_event |
| 27 | Session management | Session factory, one session per operation |
| 28 | Trade update consumer model | Single consumer dispatches by order_id |
| 29 | Shutdown with in-flight orders | Deferred (YAGNI for Step 4) |
| 30 | Commission tracking | Track as Decimal, default "0". Populate from broker if available |
